//! Additional types for [kw_kind][crate::kw_kind!].

use ::std::{
    any::type_name,
    error::Error,
    fmt::{Debug, Display},
    marker::PhantomData,
};

/// Error returned by [FromStr][::std::str::FromStr] impls generated by [kw_kind][crate::kw_kind!].
pub struct NotInSetError<Kw> {
    /// Value that is not in the keyword set.
    pub value: String,
    /// Allow for Kw to exist.
    _p: PhantomData<fn() -> Kw>,
}

impl<Kw> NotInSetError<Kw> {
    #[doc(hidden)]
    pub fn __new(value: String) -> Self {
        Self {
            value,
            _p: PhantomData,
        }
    }
}

impl<Kw> Debug for NotInSetError<Kw> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("NotInSetError")
            .field("value", &self.value)
            .field("_p", &self._p)
            .finish()
    }
}

impl<Kw> Display for NotInSetError<Kw> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "value '{}' is not in the keyword set of {}",
            self.value,
            type_name::<Kw>()
        )
    }
}

impl<Kw> Error for NotInSetError<Kw> {}

/// Create a discriminant enum and a wrapper wit ha span to parse a set of keywords.
#[macro_export]
macro_rules! kw_kind {
(
    $(#[ $($wrap_attr:tt)* ])*
    $wrap_ident:ident
    $(: $($wrap_derive:path),+ )?
    ;

    $(#[ $($kind_attr:tt)* ])*
    $kind_ident:ident
    $(: $($kind_derive:path),+ )?
    {$(
        $(#[$($keyword_attr:tt)*])*
        $keyword_ident:ident
    ),+ $(,)?}) => {

    #[derive(Clone, Copy, Debug $($(, $wrap_derive)*)*)]
    $( #[$($wrap_attr)*] )*
    pub struct $wrap_ident {
        #[doc = "Keyword variant that was parsed."]
        pub kind: $kind_ident,
        #[doc = "Span of parsed keyword."]
        pub span: $crate::__private::Span,
    }


    #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash $($(, $kind_derive)*)*)]
    $( #[$($kind_attr)*] )*
    pub enum $kind_ident {$(
        $(#[$($keyword_attr)*])*
        $keyword_ident,
    )*}

    const _: () = {

    #[doc(hidden)]
    mod kw {
        $(
        $crate::__private::custom_keyword!($keyword_ident);
        )*
    }

    impl ::std::str::FromStr for $kind_ident {
        type Err = $crate::kw_kind::NotInSetError<Self>;

        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                $(
                stringify!($keyword_ident) => Ok(Self::$keyword_ident),
                )*
                value => Err($crate::kw_kind::NotInSetError::__new(String::from(value))),
            }
        }
    }

    impl $crate::Lookahead for $wrap_ident {
        fn lookahead_peek(lookahead: &$crate::__private::Lookahead1) -> bool {
            $(
            if lookahead.peek(kw::$keyword_ident) {
                return true;
            }
            )*
            false
        }

        fn lookahead_parse(
            input: $crate::__private::ParseStream,
            lookahead: &$crate::__private::Lookahead1
        ) -> $crate::__private::syn::Result<Option<Self>> {
            $(
            if lookahead.peek(kw::$keyword_ident) {
                return input.parse().map(Some);
            }
            )*
            Ok(None)
        }
    }

    impl $crate::__private::Parse for $wrap_ident {
        #[inline]
        fn parse(input: $crate::__private::ParseStream) -> $crate::__private::syn::Result<Self> {
            let lookahead = input.lookahead1();

            $(
                if lookahead.peek(kw::$keyword_ident) {
                    Ok(Self { kind: $kind_ident::$keyword_ident, span: input.parse::<kw::$keyword_ident>()?.span })
                } else
            )*
            {
                Err(lookahead.error())
            }

        }
    }

    impl $crate::__private::ToTokens for $wrap_ident {
        fn to_tokens(&self, tokens: &mut $crate::__private::TokenStream) {
            match self.kind {$(
                $kind_ident::$keyword_ident => kw::$keyword_ident(self.span).to_tokens(tokens),
            )*}
        }
    }

    impl ::core::ops::Deref for $wrap_ident {
        type Target = $kind_ident;

        fn deref(&self) -> &Self::Target {
            &self.kind
        }
    }

    impl ::core::ops::DerefMut for $wrap_ident {
        fn deref_mut(&mut self) -> &mut Self::Target {
            &mut self.kind
        }
    }

    impl ::core::convert::AsRef<$kind_ident> for $wrap_ident {
        fn as_ref(&self) -> &$kind_ident {
            self
        }
    }

    impl ::core::convert::AsMut<$kind_ident> for $wrap_ident {
        fn as_mut(&mut self) -> &mut $kind_ident {
            self
        }
    }

    impl ::core::convert::From<$wrap_ident> for $kind_ident {
        fn from(value: $wrap_ident) -> Self {
            value.kind
        }
    }

    impl $crate::ToArg for $wrap_ident {
        type Arg = $kind_ident;

        fn to_arg(&self) -> Self::Arg { self.kind }
    }

    impl $crate::FromArg for $kind_ident {
        type Factory = $wrap_ident;

        fn from_arg(kind: $kind_ident) -> Self {
            kind
        }
    }

    };
};
}
